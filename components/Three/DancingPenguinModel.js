/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useState, useRef, useEffect, useLayoutEffect } from 'react';
import { useGLTF, useAnimations, useScroll, Text } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import gsap from 'gsap';
import * as THREE from 'three';

export function DancingPenguinModel(props) {
	const group = useRef();

	const tl = useRef();
	const scroll = useScroll();

	useFrame(() => {
		tl.current.seek(scroll.offset * tl.current.duration());
	});

	useLayoutEffect(() => {
		tl.current = gsap.timeline();

		// // // VERTICAL ANIMATION
		// tl.current.to(
		// 	group.current.scale,
		// 	{
		// 		duration: 0,
		// 		x: 0,
		// 		y: 0,
		// 		z: 0,
		// 	},
		// 	0
		// );
		// tl.current.to(
		// 	group.current.scale,
		// 	{
		// 		duration: 0.5,
		// 		x: 1,
		// 		y: 1,
		// 		z: 1,
		// 	},
		// 	1
		// );
		// // Office Rotation
		// tl.current.to(
		// 	group.current.rotation,
		// 	{ duration: 1, x: 0, y: Math.PI / 6, z: 0 },
		// 	0
		// );
		// tl.current.to(
		// 	group.current.rotation,
		// 	{ duration: 1, x: 0, y: -Math.PI / 2, z: 0 },
		// 	1
		// );

		// Office movement
		tl.current.to(
			group.current.position,
			{
				duration: 1,
				x: 0,
				z: 3,
			},
			0
		);
		tl.current.to(
			group.current.position,
			{
				duration: 1,
				x: 2,
				z: 2,
			},
			1
		);
	}, []);
	const { nodes, materials, animations } = useGLTF(
		'./assets/gltf/DancingPenguin.glb'
	);
	const { actions, names } = useAnimations(animations, group);

	useEffect(() => {
		// Reset and fade in animation after an index has been changed
		actions[names[1]].reset().fadeIn(0.5).play();
		// actions[names[2]].reset().fadeIn(0.5).play();
		actions[names[2]].reset().fadeIn(0.5).play();

		// window.setTimeout(() => {
		// 	actions[names[1]].play();
		// 	actions[names[1]].crossFadeFrom(actions[names[0]], 1);
		// }, 2000);
	}, []);

	useFrame((state, delta) => {
		// const action = actions[names[0]];
		// // The off set is between 0 and 1, you can apply it to your models any way you like
		const offset = 1 - scroll.offset;
		// action.time = THREE.MathUtils.damp(
		// 	action.time,
		// 	action.getClip().duration * offset,
		// 	100,
		// 	delta
		// );
		// console.log(action.getClip());
		state.camera.position.set(
			Math.sin(offset),
			Math.atan((offset * Math.PI) / 10),
			Math.cos((offset * Math.PI) / 3) * 12
		);

		state.camera.lookAt(-0.4, -0.3, scroll.offset);
	});
	const [word, setWord] = useState(true);
	const [hovered, setHovered] = useState(false);
	const over = e => (e.stopPropagation(), setHovered(true));
	const out = () => setHovered(false);
	const textRef = useRef();
	const color = new THREE.Color();

	useFrame(({ camera }) => {
		// Animate font color
		textRef.current.material.color.lerp(
			color.set(hovered ? 'white' : '#004A81'),
			0.1
		);
	});
	const eventHandler = () => {
		if (word) {
			setWord(false);
			actions[names[1]].stop();
			actions[names[0]].reset().fadeIn(0.5).play();
			actions[names[2]].reset().fadeIn(0.5).play();
		}
		if (!word) {
			setWord(true);
			actions[names[0]].stop();

			actions[names[1]].reset().fadeIn(0.5).play();
			actions[names[2]].reset().fadeIn(0.5).play();
		}
	};
	return (
		<group ref={group} {...props} position={[0, -2.3, -2]}>
			<group name="Scene">
				<group name="patapata" scale={[1.01, 0.93, 0.93]}>
					<primitive object={nodes.root} />
					<primitive object={nodes['MCH-torsoparent']} />
					<primitive object={nodes['MCH-hand_ikparentL']} />
					<primitive object={nodes['MCH-upper_arm_ik_targetparentL']} />
					<primitive object={nodes['MCH-hand_ikparentR']} />
					<primitive object={nodes['MCH-upper_arm_ik_targetparentR']} />
					<primitive object={nodes['MCH-foot_ikparentL']} />
					<primitive object={nodes['MCH-thigh_ik_targetparentL']} />
					<primitive object={nodes['MCH-foot_ikparentR']} />
					<primitive object={nodes['MCH-thigh_ik_targetparentR']} />
					<group name="PENGUIN">
						<skinnedMesh
							name="Cube010"
							geometry={nodes.Cube010.geometry}
							material={materials.face_black}
							skeleton={nodes.Cube010.skeleton}
							morphTargetDictionary={nodes.Cube010.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_1"
							geometry={nodes.Cube010_1.geometry}
							material={materials['Material.001']}
							skeleton={nodes.Cube010_1.skeleton}
							morphTargetDictionary={nodes.Cube010_1.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_1.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_2"
							geometry={nodes.Cube010_2.geometry}
							material={materials.eyes}
							skeleton={nodes.Cube010_2.skeleton}
							morphTargetDictionary={nodes.Cube010_2.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_2.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_3"
							geometry={nodes.Cube010_3.geometry}
							material={materials.beak}
							skeleton={nodes.Cube010_3.skeleton}
							morphTargetDictionary={nodes.Cube010_3.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_3.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_4"
							geometry={nodes.Cube010_4.geometry}
							material={materials['Material.003']}
							skeleton={nodes.Cube010_4.skeleton}
							morphTargetDictionary={nodes.Cube010_4.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_4.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_5"
							geometry={nodes.Cube010_5.geometry}
							material={materials.Ribbon}
							skeleton={nodes.Cube010_5.skeleton}
							morphTargetDictionary={nodes.Cube010_5.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_5.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_6"
							geometry={nodes.Cube010_6.geometry}
							material={materials.circle}
							skeleton={nodes.Cube010_6.skeleton}
							morphTargetDictionary={nodes.Cube010_6.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_6.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_7"
							geometry={nodes.Cube010_7.geometry}
							material={materials.star_glass}
							skeleton={nodes.Cube010_7.skeleton}
							morphTargetDictionary={nodes.Cube010_7.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_7.morphTargetInfluences}
						/>
						<skinnedMesh
							name="Cube010_8"
							geometry={nodes.Cube010_8.geometry}
							material={materials.body}
							skeleton={nodes.Cube010_8.skeleton}
							morphTargetDictionary={nodes.Cube010_8.morphTargetDictionary}
							morphTargetInfluences={nodes.Cube010_8.morphTargetInfluences}
						/>
					</group>
				</group>

				<mesh
					name="Circle009"
					castShadow
					receiveShadow
					geometry={nodes.Circle009.geometry}
					material={materials['Material.007']}
					position={[-2.93, 2.43, -0.6]}
					rotation={[1.62, 0.41, -0.37]}
					scale={1.35}
				/>
				<mesh
					name="Circle012"
					castShadow
					receiveShadow
					geometry={nodes.Circle012.geometry}
					material={materials['Material.005']}
					position={[-0.13, -0.3, -0.11]}
					scale={1.68}
				/>
				<mesh
					name="Circle010"
					castShadow
					receiveShadow
					geometry={nodes.Circle010.geometry}
					material={materials['Material.002']}
					position={[2.4, 3, -2.51]}
					rotation={[1.56, 0, 0]}
					scale={1.99}
				/>
				<mesh
					name="Circle013"
					castShadow
					receiveShadow
					geometry={nodes.Circle013.geometry}
					material={materials['Material.006']}
					position={[2.5, 0.09, 1.37]}
					rotation={[1.63, 0.76, -0.37]}
					scale={0.64}
				/>
				<mesh
					name="Circle008"
					castShadow
					receiveShadow
					geometry={nodes.Circle008.geometry}
					material={materials['Material.010']}
					position={[-1.76, 4.09, -0.04]}
					rotation={[1.55, 0, 0]}
					scale={0.66}
				/>
			</group>
			<Text
				ref={textRef}
				position={[-1.5, -0.4, 3]}
				wrapperClass="label"
				center
				distanceFactor={10}
				onPointerOver={over}
				onPointerOut={out}
				onClick={eventHandler}
			>
				{word ? 'Click Here!' : 'No more...'}
			</Text>
		</group>
	);
}

useGLTF.preload('./assets/gltf/DancingPenguin.glb');
